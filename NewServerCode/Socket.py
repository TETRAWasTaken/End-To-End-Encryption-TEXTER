import queueimport asynciofrom queue import Queueimport websocketsimport threadingimport timefrom typing import Optional, Callablefrom . import cachingimport jsonfrom database import KeyStorageclass Server:    def __init__(self, websocket,                 caching: caching.caching,                 loop: asyncio.AbstractEventLoop):        self.websocket = websocket        self.caching = caching        self.loop = loop        self.KeyStorage = KeyStorage.KeyStorage()        self.command_queue = queue.Queue()        self.associated_threads = None        self.kill_signal = False        self.USERS = []        if self.caching is None:            quit()    def _process_command(self) -> None:        """        Processes command payload, which allows other methods to run the internal methods of this class.        :return: None        """        while not self.kill_signal:            try:                command_payload = self.command_queue.get_nowait()                method_name = command_payload.get("method")                args = command_payload.get("args", ())                if method_name:                    target_method: Optional[Callable] = getattr(self, method_name, None)                    if target_method and callable(target_method):                        target_method(args)                    else:                        continue                self.command_queue.task_done()            except queue.Empty:                continue            except Exception as e:                print(f"Error in _process_command: {e}")                pass    def start(self) -> None:        """        Initiates the client communication interface        :return None:        """        print(f"Socket instance started for websocket {self.websocket.remote_address}")        try:            self.processing()        except Exception as e:            print(f"Error in Socket.Server.start: {e}")        finally:            if not self.websocket.close:                print(f"Socket instance closed for {self.websocket.remote_address}")                asyncio.run_coroutine_threadsafe(self.websocket.close(), self.loop)    def processing(self) -> None:        """        Initiates the further communication process with the client.        :return None:        """        while True:            future = asyncio.run_coroutine_threadsafe(self.websocket.recv(), self.loop)            payload = future.result()            payload = json.loads(payload)            if payload.get("status") == "Encrypted":                command_payload = {'method': 'recv_text', 'args': payload}                self.command_queue.put(command_payload)            elif payload.get("status") == "User_Select":                command_payload = {'method': 'select_user', 'args': payload}                self.command_queue.put(command_payload)    def recv_text(self, recv_payload: dict):        """        Processes the received text from the current client         and redirects to the correct user        :param recv_payload:        """        message = recv_payload.get("message").get("text")        recv_id = recv_payload.get("message").get("user_id")        sender_id = recv_payload.get("message").get("sender_user_id")        try:            if self.caching.send_text(sender_id, recv_id, message):                print(f"Text sent to {recv_id} from {sender_id}")            else:                print(f"Error while sending text to {recv_id} from {sender_id}")        except Exception as e:            print(f"Error in caching.send_text: {e}")    def send_text(self, msg_payload: dict):        """        Send the text to the client        :param msg_payload:        """        try:            asyncio.run_coroutine_threadsafe(self.websocket.send(json.dumps(msg_payload)), self.loop)        except Exception as e:            print(f"Error in socket.send_text: {e}")            pass    def select_user(self, user_payload: dict):        """        Processes the selected user from the client, and redirects to the correct user        :param user_payload:        """        user_id = user_payload.get("user_id")        try:            if self.caching.check_ACTIVEUSER(user_id):                payload = {'status': 'User_Select', 'message': 'User Available'}                asyncio.run_coroutine_threadsafe(self.websocket.send(json.dumps(payload)), self.loop)            else:                payload = {'status': 'User_Select', 'message': 'User Not Available'}                asyncio.run_coroutine_threadsafe(self.websocket.send(json.dumps(payload)), self.loop)        except Exception as e:            print(f"Error in caching.select_user: {e}")